/**
 * Unified Vulnerability Scanner
 * 
 * Comprehensive vulnerability scanning system for dependencies, code analysis,
 * configuration review, and secrets detection.
 */

import { readFile, readdir, stat } from 'fs/promises';
import { join, extname } from 'path';
import { EventEmitter } from 'events';

export class VulnerabilityScanner extends EventEmitter {
    constructor(config, auditLogger) {
        super();
        
        this.config = {
            enabled: true,
            schedule: {
                enabled: false,
                cron: '0 2 * * *' // Daily at 2 AM
            },
            scans: {
                dependencies: true,
                codeAnalysis: true,
                configurationReview: true,
                secretsDetection: true
            },
            reporting: {
                enabled: true,
                format: 'json',
                destinations: ['file'],
                severity: {
                    critical: true,
                    high: true,
                    medium: true,
                    low: false
                }
            },
            ...config
        };
        
        this.auditLogger = auditLogger;
        
        // Vulnerability databases
        this.knownVulnerabilities = new Map();
        this.secretPatterns = this._getSecretPatterns();
        this.configurationRules = this._getConfigurationRules();
        this.codePatterns = this._getCodePatterns();
        
        // Scan results
        this.lastScanResults = null;
        this.scanHistory = [];
        
        this.initialized = false;
    }

    /**
     * Initialize vulnerability scanner
     */
    async initialize() {
        try {
            // Load vulnerability databases
            await this._loadVulnerabilityDatabases();
            
            // Setup scheduled scanning if enabled
            if (this.config.schedule.enabled) {
                this._setupScheduledScanning();
            }
            
            this.initialized = true;
            this.emit('initialized');
            
            if (this.auditLogger) {
                await this.auditLogger.logSecurityEvent('VULNERABILITY_SCANNER_INITIALIZED', {
                    scansEnabled: this.config.scans,
                    schedulingEnabled: this.config.schedule.enabled
                });
            }
            
        } catch (error) {
            this.emit('error', error);
            throw error;
        }
    }

    /**
     * Run comprehensive vulnerability scan
     */
    async runScan(options = {}) {
        if (!this.initialized) {
            throw new Error('Vulnerability scanner not initialized');
        }

        const scanId = this._generateScanId();
        const startTime = Date.now();
        
        try {
            const scanResults = {
                scanId,
                timestamp: new Date().toISOString(),
                options,
                results: {
                    dependencies: null,
                    codeAnalysis: null,
                    configuration: null,
                    secrets: null
                },
                summary: {
                    totalVulnerabilities: 0,
                    criticalCount: 0,
                    highCount: 0,
                    mediumCount: 0,
                    lowCount: 0
                },
                duration: 0
            };

            // Run dependency scan
            if (this.config.scans.dependencies) {
                scanResults.results.dependencies = await this._scanDependencies(options);
            }

            // Run code analysis
            if (this.config.scans.codeAnalysis) {
                scanResults.results.codeAnalysis = await this._scanCode(options);
            }

            // Run configuration review
            if (this.config.scans.configurationReview) {
                scanResults.results.configuration = await this._scanConfiguration(options);
            }

            // Run secrets detection
            if (this.config.scans.secretsDetection) {
                scanResults.results.secrets = await this._scanSecrets(options);
            }

            // Calculate summary
            this._calculateSummary(scanResults);
            
            scanResults.duration = Date.now() - startTime;
            this.lastScanResults = scanResults;
            this.scanHistory.push(scanResults);
            
            // Generate report if enabled
            if (this.config.reporting.enabled) {
                await this._generateReport(scanResults);
            }

            // Log scan completion
            if (this.auditLogger) {
                await this.auditLogger.logSecurityEvent('VULNERABILITY_SCAN_COMPLETED', {
                    scanId,
                    duration: scanResults.duration,
                    totalVulnerabilities: scanResults.summary.totalVulnerabilities,
                    criticalCount: scanResults.summary.criticalCount
                });
            }

            this.emit('scanCompleted', scanResults);
            return scanResults;

        } catch (error) {
            if (this.auditLogger) {
                await this.auditLogger.logSecurityEvent('VULNERABILITY_SCAN_FAILED', {
                    scanId,
                    error: error.message,
                    duration: Date.now() - startTime
                });
            }

            this.emit('scanError', { scanId, error });
            throw error;
        }
    }

    /**
     * Scan dependencies for vulnerabilities
     */
    async _scanDependencies(options) {
        const results = {
            type: 'dependencies',
            vulnerabilities: [],
            scannedPackages: 0,
            timestamp: new Date().toISOString()
        };

        try {
            // Read package.json
            const packageJsonPath = options.packageJsonPath || './package.json';
            const packageJson = JSON.parse(await readFile(packageJsonPath, 'utf8'));
            
            const dependencies = {
                ...packageJson.dependencies || {},
                ...packageJson.devDependencies || {}
            };

            results.scannedPackages = Object.keys(dependencies).length;

            // Check each dependency against known vulnerabilities
            for (const [packageName, version] of Object.entries(dependencies)) {
                const vulnerabilities = await this._checkPackageVulnerabilities(packageName, version);
                results.vulnerabilities.push(...vulnerabilities);
            }

        } catch (error) {
            results.error = error.message;
        }

        return results;
    }

    /**
     * Scan code for security issues
     */
    async _scanCode(options) {
        const results = {
            type: 'codeAnalysis',
            vulnerabilities: [],
            scannedFiles: 0,
            timestamp: new Date().toISOString()
        };

        try {
            const sourceDir = options.sourceDir || './src';
            const files = await this._getSourceFiles(sourceDir);
            
            results.scannedFiles = files.length;

            for (const filePath of files) {
                const fileVulnerabilities = await this._scanFile(filePath);
                results.vulnerabilities.push(...fileVulnerabilities);
            }

        } catch (error) {
            results.error = error.message;
        }

        return results;
    }

    /**
     * Scan configuration for security issues
     */
    async _scanConfiguration(options) {
        const results = {
            type: 'configuration',
            vulnerabilities: [],
            scannedConfigs: 0,
            timestamp: new Date().toISOString()
        };

        try {
            const configFiles = await this._getConfigFiles(options.configDir || '.');
            results.scannedConfigs = configFiles.length;

            for (const configFile of configFiles) {
                const configVulnerabilities = await this._scanConfigFile(configFile);
                results.vulnerabilities.push(...configVulnerabilities);
            }

        } catch (error) {
            results.error = error.message;
        }

        return results;
    }

    /**
     * Scan for secrets and credentials
     */
    async _scanSecrets(options) {
        const results = {
            type: 'secrets',
            vulnerabilities: [],
            scannedFiles: 0,
            timestamp: new Date().toISOString()
        };

        try {
            const sourceDir = options.sourceDir || '.';
            const files = await this._getAllFiles(sourceDir);
            
            results.scannedFiles = files.length;

            for (const filePath of files) {
                const secrets = await this._scanFileForSecrets(filePath);
                results.vulnerabilities.push(...secrets);
            }

        } catch (error) {
            results.error = error.message;
        }

        return results;
    }

    /**
     * Check package vulnerabilities
     */
    async _checkPackageVulnerabilities(packageName, version) {
        const vulnerabilities = [];
        
        // Check against known vulnerability database
        const packageVulns = this.knownVulnerabilities.get(packageName) || [];
        
        for (const vuln of packageVulns) {
            if (this._isVersionAffected(version, vuln.affectedVersions)) {
                vulnerabilities.push({
                    id: vuln.id,
                    package: packageName,
                    version,
                    severity: vuln.severity,
                    title: vuln.title,
                    description: vuln.description,
                    cve: vuln.cve,
                    references: vuln.references,
                    fixedIn: vuln.fixedIn
                });
            }
        }

        return vulnerabilities;
    }

    /**
     * Scan individual file for code vulnerabilities
     */
    async _scanFile(filePath) {
        const vulnerabilities = [];
        
        try {
            const content = await readFile(filePath, 'utf8');
            const lines = content.split('\n');

            for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
                const line = lines[lineNumber];
                
                for (const [patternName, pattern] of Object.entries(this.codePatterns)) {
                    const matches = line.match(pattern.regex);
                    if (matches) {
                        vulnerabilities.push({
                            id: `code-${patternName}-${Date.now()}`,
                            type: 'code',
                            file: filePath,
                            line: lineNumber + 1,
                            severity: pattern.severity,
                            title: pattern.title,
                            description: pattern.description,
                            code: line.trim(),
                            recommendation: pattern.recommendation
                        });
                    }
                }
            }

        } catch (error) {
            // Skip files that can't be read
        }

        return vulnerabilities;
    }

    /**
     * Scan configuration file
     */
    async _scanConfigFile(filePath) {
        const vulnerabilities = [];
        
        try {
            const content = await readFile(filePath, 'utf8');
            let config;

            // Parse configuration based on file type
            if (filePath.endsWith('.json')) {
                config = JSON.parse(content);
            } else if (filePath.endsWith('.env')) {
                config = this._parseEnvFile(content);
            } else {
                return vulnerabilities; // Skip unsupported formats
            }

            // Check against configuration rules
            for (const rule of this.configurationRules) {
                const ruleViolations = this._checkConfigurationRule(config, rule, filePath);
                vulnerabilities.push(...ruleViolations);
            }

        } catch (error) {
            // Skip files that can't be parsed
        }

        return vulnerabilities;
    }

    /**
     * Scan file for secrets
     */
    async _scanFileForSecrets(filePath) {
        const secrets = [];
        
        try {
            const content = await readFile(filePath, 'utf8');
            const lines = content.split('\n');

            for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
                const line = lines[lineNumber];
                
                for (const [patternName, pattern] of Object.entries(this.secretPatterns)) {
                    const matches = line.match(pattern.regex);
                    if (matches) {
                        secrets.push({
                            id: `secret-${patternName}-${Date.now()}`,
                            type: 'secret',
                            secretType: patternName,
                            file: filePath,
                            line: lineNumber + 1,
                            severity: 'high',
                            title: `${pattern.name} detected`,
                            description: `Potential ${pattern.name} found in source code`,
                            recommendation: 'Remove hardcoded secrets and use environment variables or secure vaults'
                        });
                    }
                }
            }

        } catch (error) {
            // Skip files that can't be read
        }

        return secrets;
    }

    /**
     * Get secret detection patterns
     */
    _getSecretPatterns() {
        return {
            awsAccessKey: {
                name: 'AWS Access Key',
                regex: /AKIA[0-9A-Z]{16}/g
            },
            awsSecretKey: {
                name: 'AWS Secret Key',
                regex: /[0-9a-zA-Z/+]{40}/g
            },
            githubToken: {
                name: 'GitHub Token',
                regex: /ghp_[0-9a-zA-Z]{36}/g
            },
            slackToken: {
                name: 'Slack Token',
                regex: /xox[baprs]-[0-9a-zA-Z-]{10,48}/g
            },
            jwtToken: {
                name: 'JWT Token',
                regex: /eyJ[0-9a-zA-Z_-]*\.[0-9a-zA-Z_-]*\.[0-9a-zA-Z_-]*/g
            },
            apiKey: {
                name: 'API Key',
                regex: /[aA][pP][iI][_]?[kK][eE][yY].*['\"][0-9a-zA-Z]{32,45}['\"]|[aA][pP][iI][_]?[kK][eE][yY].*[=:]\s*[0-9a-zA-Z]{32,45}/g
            },
            password: {
                name: 'Password',
                regex: /[pP][aA][sS][sS][wW][oO][rR][dD].*['\"][^'\"]{8,}['\"]|[pP][aA][sS][sS][wW][oO][rR][dD].*[=:]\s*[^'\"]{8,}/g
            },
            privateKey: {
                name: 'Private Key',
                regex: /-----BEGIN [A-Z ]+PRIVATE KEY-----/g
            }
        };
    }

    /**
     * Get configuration security rules
     */
    _getConfigurationRules() {
        return [
            {
                name: 'Debug Mode Enabled',
                check: (config) => config.debug === true || config.DEBUG === 'true',
                severity: 'medium',
                description: 'Debug mode should be disabled in production',
                recommendation: 'Set debug to false in production environments'
            },
            {
                name: 'Insecure HTTP',
                check: (config) => {
                    const urls = JSON.stringify(config).toLowerCase();
                    return urls.includes('http://') && !urls.includes('localhost');
                },
                severity: 'high',
                description: 'HTTP URLs detected, should use HTTPS',
                recommendation: 'Use HTTPS for all external communications'
            },
            {
                name: 'Weak Session Secret',
                check: (config) => {
                    const secret = config.sessionSecret || config.SESSION_SECRET;
                    return secret && secret.length < 32;
                },
                severity: 'high',
                description: 'Session secret is too short',
                recommendation: 'Use a session secret of at least 32 characters'
            }
        ];
    }

    /**
     * Get code analysis patterns
     */
    _getCodePatterns() {
        return {
            sqlInjection: {
                regex: /query\s*\(\s*['"]\s*SELECT.*\+.*['"]\s*\)|exec\s*\(\s*['"]\s*SELECT.*\+.*['"]\s*\)/gi,
                severity: 'high',
                title: 'Potential SQL Injection',
                description: 'Dynamic SQL query construction detected',
                recommendation: 'Use parameterized queries or prepared statements'
            },
            hardcodedPassword: {
                regex: /password\s*[=:]\s*['"]\w{6,}['"]/gi,
                severity: 'high',
                title: 'Hardcoded Password',
                description: 'Password hardcoded in source code',
                recommendation: 'Use environment variables or secure configuration'
            },
            weakCrypto: {
                regex: /md5|sha1|des|rc4/gi,
                severity: 'medium',
                title: 'Weak Cryptographic Algorithm',
                description: 'Weak or deprecated cryptographic algorithm detected',
                recommendation: 'Use strong algorithms like SHA-256, AES-256, or bcrypt'
            },
            unsafeEval: {
                regex: /eval\s*\(/gi,
                severity: 'high',
                title: 'Unsafe eval() Usage',
                description: 'Use of eval() function detected',
                recommendation: 'Avoid eval() and use safer alternatives'
            }
        };
    }

    /**
     * Load vulnerability databases
     */
    async _loadVulnerabilityDatabases() {
        // TODO: Load from external vulnerability databases
        // For now, use a simple in-memory database
        this.knownVulnerabilities.set('lodash', [
            {
                id: 'CVE-2019-10744',
                severity: 'high',
                title: 'Prototype Pollution',
                description: 'Versions of lodash before 4.17.12 are vulnerable to Prototype Pollution',
                cve: 'CVE-2019-10744',
                affectedVersions: '<4.17.12',
                fixedIn: '4.17.12',
                references: ['https://nvd.nist.gov/vuln/detail/CVE-2019-10744']
            }
        ]);
    }

    /**
     * Setup scheduled scanning
     */
    _setupScheduledScanning() {
        // TODO: Implement cron-based scheduling
        console.log('Scheduled scanning would be set up with cron:', this.config.schedule.cron);
    }

    /**
     * Generate scan ID
     */
    _generateScanId() {
        return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Calculate scan summary
     */
    _calculateSummary(scanResults) {
        const summary = scanResults.summary;
        
        for (const result of Object.values(scanResults.results)) {
            if (result && result.vulnerabilities) {
                for (const vuln of result.vulnerabilities) {
                    summary.totalVulnerabilities++;
                    
                    switch (vuln.severity) {
                        case 'critical':
                            summary.criticalCount++;
                            break;
                        case 'high':
                            summary.highCount++;
                            break;
                        case 'medium':
                            summary.mediumCount++;
                            break;
                        case 'low':
                            summary.lowCount++;
                            break;
                    }
                }
            }
        }
    }

    /**
     * Generate vulnerability report
     */
    async _generateReport(scanResults) {
        // TODO: Implement report generation
        console.log('Would generate vulnerability report for scan:', scanResults.scanId);
    }

    /**
     * Get source files
     */
    async _getSourceFiles(dir) {
        const files = [];
        const extensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.php'];
        
        await this._walkDirectory(dir, (filePath) => {
            if (extensions.includes(extname(filePath))) {
                files.push(filePath);
            }
        });
        
        return files;
    }

    /**
     * Get configuration files
     */
    async _getConfigFiles(dir) {
        const files = [];
        const configPatterns = ['.env', 'config.json', 'package.json', '.npmrc'];
        
        await this._walkDirectory(dir, (filePath) => {
            const fileName = filePath.split('/').pop();
            if (configPatterns.some(pattern => fileName.includes(pattern))) {
                files.push(filePath);
            }
        });
        
        return files;
    }

    /**
     * Get all files
     */
    async _getAllFiles(dir) {
        const files = [];
        
        await this._walkDirectory(dir, (filePath) => {
            files.push(filePath);
        });
        
        return files;
    }

    /**
     * Walk directory recursively
     */
    async _walkDirectory(dir, callback) {
        try {
            const entries = await readdir(dir);
            
            for (const entry of entries) {
                const fullPath = join(dir, entry);
                const stats = await stat(fullPath);
                
                if (stats.isDirectory()) {
                    // Skip node_modules and other common directories
                    if (!['node_modules', '.git', '.vscode', 'dist', 'build'].includes(entry)) {
                        await this._walkDirectory(fullPath, callback);
                    }
                } else {
                    callback(fullPath);
                }
            }
        } catch (error) {
            // Skip directories that can't be read
        }
    }

    /**
     * Check if version is affected by vulnerability
     */
    _isVersionAffected(version, affectedVersions) {
        // Simple version comparison - in production, use a proper semver library
        return true; // Simplified for demo
    }

    /**
     * Parse environment file
     */
    _parseEnvFile(content) {
        const config = {};
        const lines = content.split('\n');
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed && !trimmed.startsWith('#')) {
                const [key, ...valueParts] = trimmed.split('=');
                if (key && valueParts.length > 0) {
                    config[key.trim()] = valueParts.join('=').trim();
                }
            }
        }
        
        return config;
    }

    /**
     * Check configuration rule
     */
    _checkConfigurationRule(config, rule, filePath) {
        const violations = [];
        
        if (rule.check(config)) {
            violations.push({
                id: `config-${rule.name.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`,
                type: 'configuration',
                file: filePath,
                severity: rule.severity,
                title: rule.name,
                description: rule.description,
                recommendation: rule.recommendation
            });
        }
        
        return violations;
    }

    /**
     * Get last scan results
     */
    getLastScanResults() {
        return this.lastScanResults;
    }

    /**
     * Get scan history
     */
    getScanHistory(limit = 10) {
        return this.scanHistory.slice(-limit);
    }

    /**
     * Health check
     */
    async healthCheck() {
        return {
            status: 'ok',
            enabled: this.config.enabled,
            scansEnabled: this.config.scans,
            lastScan: this.lastScanResults?.timestamp,
            totalScans: this.scanHistory.length
        };
    }

    /**
     * Shutdown
     */
    async shutdown() {
        this.initialized = false;
    }
}

export default VulnerabilityScanner;

