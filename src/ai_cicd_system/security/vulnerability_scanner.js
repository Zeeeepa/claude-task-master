/**
 * Vulnerability Scanner
 * Automated security scanning, dependency analysis, and vulnerability management
 */

import { EventEmitter } from 'events';
import { spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { AuditLogger } from './audit_logger.js';

export class VulnerabilityScanner extends EventEmitter {
    constructor(config = {}) {
        super();
        this.config = {
            scanInterval: config.scanInterval || 24 * 60 * 60 * 1000, // 24 hours
            enableContinuousScanning: config.enableContinuousScanning !== false,
            scanners: config.scanners || ['npm-audit', 'snyk', 'owasp-zap'],
            severityThreshold: config.severityThreshold || 'medium',
            autoFix: config.autoFix || false,
            reportDirectory: config.reportDirectory || './reports/security',
            excludePatterns: config.excludePatterns || ['node_modules', '.git', 'logs'],
            maxScanDuration: config.maxScanDuration || 30 * 60 * 1000, // 30 minutes
            ...config
        };

        this.auditLogger = new AuditLogger();
        this.scanHistory = new Map();
        this.vulnerabilities = new Map();
        this.scanners = new Map();
        
        this.initializeScanners();
        
        if (this.config.enableContinuousScanning) {
            this.startContinuousScanning();
        }
    }

    /**
     * Initialize available scanners
     */
    initializeScanners() {
        // NPM Audit Scanner
        this.scanners.set('npm-audit', {
            name: 'NPM Audit',
            command: 'npm',
            args: ['audit', '--json'],
            parser: this.parseNpmAuditResults.bind(this),
            enabled: this.config.scanners.includes('npm-audit')
        });

        // Snyk Scanner
        this.scanners.set('snyk', {
            name: 'Snyk',
            command: 'snyk',
            args: ['test', '--json'],
            parser: this.parseSnykResults.bind(this),
            enabled: this.config.scanners.includes('snyk')
        });

        // OWASP ZAP Scanner
        this.scanners.set('owasp-zap', {
            name: 'OWASP ZAP',
            command: 'zap-baseline.py',
            args: ['-t', 'http://localhost:3000', '-J', 'zap-report.json'],
            parser: this.parseOwaspZapResults.bind(this),
            enabled: this.config.scanners.includes('owasp-zap')
        });

        // Custom Static Analysis Scanner
        this.scanners.set('static-analysis', {
            name: 'Static Analysis',
            command: null, // Internal implementation
            parser: this.parseStaticAnalysisResults.bind(this),
            enabled: true
        });
    }

    /**
     * Run comprehensive security scan
     */
    async runScan(options = {}) {
        const scanId = this.generateScanId();
        const startTime = new Date();
        
        try {
            await this.auditLogger.logSecurityEvent('VULNERABILITY_SCAN_STARTED', {
                scanId,
                scanners: Array.from(this.scanners.keys()).filter(key => this.scanners.get(key).enabled),
                options
            });

            const scanResults = {
                scanId,
                startTime,
                endTime: null,
                status: 'running',
                vulnerabilities: [],
                summary: {},
                scanners: {}
            };

            // Create report directory
            await fs.mkdir(this.config.reportDirectory, { recursive: true });

            // Run enabled scanners
            for (const [scannerId, scanner] of this.scanners) {
                if (!scanner.enabled) continue;

                try {
                    const scannerResults = await this.runScanner(scannerId, scanner, options);
                    scanResults.scanners[scannerId] = scannerResults;
                    scanResults.vulnerabilities.push(...scannerResults.vulnerabilities);
                } catch (error) {
                    await this.auditLogger.logSecurityEvent('SCANNER_FAILED', {
                        scanId,
                        scannerId,
                        error: error.message
                    });
                    
                    scanResults.scanners[scannerId] = {
                        status: 'failed',
                        error: error.message,
                        vulnerabilities: []
                    };
                }
            }

            // Generate summary
            scanResults.summary = this.generateScanSummary(scanResults.vulnerabilities);
            scanResults.endTime = new Date();
            scanResults.status = 'completed';
            scanResults.duration = scanResults.endTime - scanResults.startTime;

            // Store scan results
            this.scanHistory.set(scanId, scanResults);
            
            // Update vulnerability database
            this.updateVulnerabilityDatabase(scanResults.vulnerabilities);

            // Generate report
            await this.generateScanReport(scanResults);

            // Handle critical vulnerabilities
            await this.handleCriticalVulnerabilities(scanResults.vulnerabilities);

            await this.auditLogger.logSecurityEvent('VULNERABILITY_SCAN_COMPLETED', {
                scanId,
                duration: scanResults.duration,
                vulnerabilitiesFound: scanResults.vulnerabilities.length,
                summary: scanResults.summary
            });

            this.emit('scanCompleted', scanResults);
            return scanResults;

        } catch (error) {
            await this.auditLogger.logSecurityEvent('VULNERABILITY_SCAN_FAILED', {
                scanId,
                error: error.message,
                duration: Date.now() - startTime
            });

            this.emit('scanFailed', { scanId, error });
            throw error;
        }
    }

    /**
     * Run individual scanner
     */
    async runScanner(scannerId, scanner, options) {
        const startTime = Date.now();
        
        try {
            let results;
            
            if (scannerId === 'static-analysis') {
                results = await this.runStaticAnalysis(options);
            } else {
                results = await this.runExternalScanner(scanner, options);
            }

            const vulnerabilities = await scanner.parser(results);

            return {
                scannerId,
                name: scanner.name,
                status: 'completed',
                duration: Date.now() - startTime,
                vulnerabilities,
                rawResults: results
            };

        } catch (error) {
            return {
                scannerId,
                name: scanner.name,
                status: 'failed',
                duration: Date.now() - startTime,
                error: error.message,
                vulnerabilities: []
            };
        }
    }

    /**
     * Run external scanner command
     */
    async runExternalScanner(scanner, options) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                process.kill();
                reject(new Error(`Scanner timeout after ${this.config.maxScanDuration}ms`));
            }, this.config.maxScanDuration);

            let output = '';
            let errorOutput = '';

            const process = spawn(scanner.command, scanner.args, {
                cwd: options.targetDirectory || process.cwd(),
                stdio: 'pipe'
            });

            process.stdout.on('data', (data) => {
                output += data.toString();
            });

            process.stderr.on('data', (data) => {
                errorOutput += data.toString();
            });

            process.on('close', (code) => {
                clearTimeout(timeout);
                
                if (code === 0 || (code === 1 && output)) {
                    // Some scanners return exit code 1 when vulnerabilities are found
                    resolve(output);
                } else {
                    reject(new Error(`Scanner failed with code ${code}: ${errorOutput}`));
                }
            });

            process.on('error', (error) => {
                clearTimeout(timeout);
                reject(error);
            });
        });
    }

    /**
     * Run static analysis
     */
    async runStaticAnalysis(options) {
        const targetDir = options.targetDirectory || process.cwd();
        const results = {
            files: [],
            patterns: [],
            dependencies: []
        };

        // Scan JavaScript/TypeScript files
        const jsFiles = await this.findFiles(targetDir, ['.js', '.ts', '.jsx', '.tsx']);
        
        for (const file of jsFiles) {
            const content = await fs.readFile(file, 'utf8');
            const fileResults = await this.analyzeFile(file, content);
            results.files.push(fileResults);
        }

        // Analyze package.json for dependency vulnerabilities
        const packageJsonPath = path.join(targetDir, 'package.json');
        try {
            const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
            results.dependencies = await this.analyzeDependencies(packageJson);
        } catch (error) {
            // package.json not found or invalid
        }

        return results;
    }

    /**
     * Find files with specific extensions
     */
    async findFiles(directory, extensions, excludePatterns = this.config.excludePatterns) {
        const files = [];
        
        async function scanDirectory(dir) {
            const entries = await fs.readdir(dir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                // Skip excluded patterns
                if (excludePatterns.some(pattern => fullPath.includes(pattern))) {
                    continue;
                }
                
                if (entry.isDirectory()) {
                    await scanDirectory(fullPath);
                } else if (extensions.some(ext => entry.name.endsWith(ext))) {
                    files.push(fullPath);
                }
            }
        }
        
        await scanDirectory(directory);
        return files;
    }

    /**
     * Analyze individual file for security issues
     */
    async analyzeFile(filePath, content) {
        const vulnerabilities = [];
        
        // Check for hardcoded secrets
        const secretPatterns = [
            { pattern: /password\s*=\s*["'][^"']+["']/gi, type: 'hardcoded_password' },
            { pattern: /api[_-]?key\s*=\s*["'][^"']+["']/gi, type: 'hardcoded_api_key' },
            { pattern: /secret\s*=\s*["'][^"']+["']/gi, type: 'hardcoded_secret' },
            { pattern: /token\s*=\s*["'][^"']+["']/gi, type: 'hardcoded_token' },
            { pattern: /[a-zA-Z0-9]{32,}/g, type: 'potential_secret' }
        ];

        secretPatterns.forEach(({ pattern, type }) => {
            const matches = content.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    vulnerabilities.push({
                        type,
                        severity: 'high',
                        description: `Potential hardcoded secret found: ${type}`,
                        location: filePath,
                        evidence: match.substring(0, 50) + '...'
                    });
                });
            }
        });

        // Check for dangerous functions
        const dangerousFunctions = [
            { pattern: /eval\s*\(/gi, type: 'dangerous_eval' },
            { pattern: /innerHTML\s*=/gi, type: 'potential_xss' },
            { pattern: /document\.write\s*\(/gi, type: 'dangerous_document_write' },
            { pattern: /exec\s*\(/gi, type: 'command_execution' }
        ];

        dangerousFunctions.forEach(({ pattern, type }) => {
            const matches = content.match(pattern);
            if (matches) {
                vulnerabilities.push({
                    type,
                    severity: 'medium',
                    description: `Dangerous function usage: ${type}`,
                    location: filePath,
                    count: matches.length
                });
            }
        });

        // Check for SQL injection patterns
        const sqlPatterns = [
            /query\s*\+\s*["']/gi,
            /SELECT\s+.*\s+FROM\s+.*\s*\+/gi,
            /INSERT\s+INTO\s+.*\s*\+/gi
        ];

        sqlPatterns.forEach(pattern => {
            const matches = content.match(pattern);
            if (matches) {
                vulnerabilities.push({
                    type: 'potential_sql_injection',
                    severity: 'high',
                    description: 'Potential SQL injection vulnerability',
                    location: filePath,
                    count: matches.length
                });
            }
        });

        return {
            file: filePath,
            vulnerabilities,
            linesOfCode: content.split('\n').length
        };
    }

    /**
     * Analyze dependencies for known vulnerabilities
     */
    async analyzeDependencies(packageJson) {
        const vulnerabilities = [];
        const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

        // This would typically integrate with vulnerability databases
        // For now, we'll check for some known problematic packages
        const knownVulnerablePackages = {
            'lodash': { versions: ['<4.17.21'], severity: 'high', cve: 'CVE-2021-23337' },
            'axios': { versions: ['<0.21.1'], severity: 'medium', cve: 'CVE-2020-28168' },
            'express': { versions: ['<4.17.1'], severity: 'medium', cve: 'CVE-2019-5413' }
        };

        for (const [packageName, version] of Object.entries(dependencies)) {
            if (knownVulnerablePackages[packageName]) {
                const vulnInfo = knownVulnerablePackages[packageName];
                vulnerabilities.push({
                    type: 'vulnerable_dependency',
                    severity: vulnInfo.severity,
                    description: `Vulnerable dependency: ${packageName}@${version}`,
                    package: packageName,
                    version,
                    cve: vulnInfo.cve,
                    recommendation: `Update to latest version`
                });
            }
        }

        return vulnerabilities;
    }

    /**
     * Parse NPM Audit results
     */
    async parseNpmAuditResults(output) {
        try {
            const results = JSON.parse(output);
            const vulnerabilities = [];

            if (results.vulnerabilities) {
                for (const [packageName, vulnData] of Object.entries(results.vulnerabilities)) {
                    vulnerabilities.push({
                        type: 'npm_vulnerability',
                        severity: vulnData.severity,
                        description: vulnData.title || 'NPM vulnerability',
                        package: packageName,
                        version: vulnData.range,
                        cve: vulnData.cves?.[0],
                        recommendation: vulnData.fixAvailable ? 'Update available' : 'No fix available'
                    });
                }
            }

            return vulnerabilities;
        } catch (error) {
            throw new Error(`Failed to parse NPM audit results: ${error.message}`);
        }
    }

    /**
     * Parse Snyk results
     */
    async parseSnykResults(output) {
        try {
            const results = JSON.parse(output);
            const vulnerabilities = [];

            if (results.vulnerabilities) {
                results.vulnerabilities.forEach(vuln => {
                    vulnerabilities.push({
                        type: 'snyk_vulnerability',
                        severity: vuln.severity,
                        description: vuln.title,
                        package: vuln.packageName,
                        version: vuln.version,
                        cve: vuln.identifiers?.CVE?.[0],
                        recommendation: vuln.fixedIn ? `Update to ${vuln.fixedIn}` : 'No fix available'
                    });
                });
            }

            return vulnerabilities;
        } catch (error) {
            throw new Error(`Failed to parse Snyk results: ${error.message}`);
        }
    }

    /**
     * Parse OWASP ZAP results
     */
    async parseOwaspZapResults(output) {
        try {
            const results = JSON.parse(output);
            const vulnerabilities = [];

            if (results.site) {
                results.site.forEach(site => {
                    site.alerts?.forEach(alert => {
                        vulnerabilities.push({
                            type: 'web_vulnerability',
                            severity: this.mapZapSeverity(alert.riskdesc),
                            description: alert.name,
                            url: alert.url,
                            method: alert.method,
                            evidence: alert.evidence,
                            recommendation: alert.solution
                        });
                    });
                });
            }

            return vulnerabilities;
        } catch (error) {
            throw new Error(`Failed to parse OWASP ZAP results: ${error.message}`);
        }
    }

    /**
     * Parse static analysis results
     */
    async parseStaticAnalysisResults(results) {
        const vulnerabilities = [];

        // Combine vulnerabilities from all files
        results.files.forEach(fileResult => {
            vulnerabilities.push(...fileResult.vulnerabilities);
        });

        // Add dependency vulnerabilities
        vulnerabilities.push(...results.dependencies);

        return vulnerabilities;
    }

    /**
     * Map ZAP severity to standard levels
     */
    mapZapSeverity(zapSeverity) {
        const severityMap = {
            'High': 'high',
            'Medium': 'medium',
            'Low': 'low',
            'Informational': 'info'
        };
        
        return severityMap[zapSeverity] || 'medium';
    }

    /**
     * Generate scan summary
     */
    generateScanSummary(vulnerabilities) {
        const summary = {
            total: vulnerabilities.length,
            bySeverity: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
            byType: {},
            riskScore: 0
        };

        vulnerabilities.forEach(vuln => {
            // Count by severity
            const severity = vuln.severity || 'medium';
            summary.bySeverity[severity] = (summary.bySeverity[severity] || 0) + 1;

            // Count by type
            summary.byType[vuln.type] = (summary.byType[vuln.type] || 0) + 1;
        });

        // Calculate risk score
        summary.riskScore = (
            summary.bySeverity.critical * 10 +
            summary.bySeverity.high * 7 +
            summary.bySeverity.medium * 4 +
            summary.bySeverity.low * 1
        );

        return summary;
    }

    /**
     * Update vulnerability database
     */
    updateVulnerabilityDatabase(vulnerabilities) {
        vulnerabilities.forEach(vuln => {
            const vulnId = this.generateVulnerabilityId(vuln);
            this.vulnerabilities.set(vulnId, {
                ...vuln,
                id: vulnId,
                firstSeen: this.vulnerabilities.get(vulnId)?.firstSeen || new Date(),
                lastSeen: new Date(),
                status: 'open'
            });
        });
    }

    /**
     * Generate vulnerability ID
     */
    generateVulnerabilityId(vulnerability) {
        const key = `${vulnerability.type}:${vulnerability.package || vulnerability.location || 'unknown'}`;
        return Buffer.from(key).toString('base64').replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
    }

    /**
     * Generate scan report
     */
    async generateScanReport(scanResults) {
        const reportPath = path.join(
            this.config.reportDirectory,
            `vulnerability-scan-${scanResults.scanId}.json`
        );

        const report = {
            ...scanResults,
            generatedAt: new Date().toISOString(),
            recommendations: this.generateRecommendations(scanResults.vulnerabilities)
        };

        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));

        // Generate HTML report
        const htmlReport = this.generateHTMLReport(report);
        const htmlPath = reportPath.replace('.json', '.html');
        await fs.writeFile(htmlPath, htmlReport);

        return { jsonReport: reportPath, htmlReport: htmlPath };
    }

    /**
     * Generate recommendations
     */
    generateRecommendations(vulnerabilities) {
        const recommendations = [];
        const severityCount = vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
            return acc;
        }, {});

        if (severityCount.critical > 0) {
            recommendations.push({
                priority: 'critical',
                action: 'Immediately address critical vulnerabilities',
                description: `Found ${severityCount.critical} critical vulnerabilities that require immediate attention`
            });
        }

        if (severityCount.high > 0) {
            recommendations.push({
                priority: 'high',
                action: 'Address high-severity vulnerabilities within 24 hours',
                description: `Found ${severityCount.high} high-severity vulnerabilities`
            });
        }

        // Add specific recommendations based on vulnerability types
        const typeCount = vulnerabilities.reduce((acc, vuln) => {
            acc[vuln.type] = (acc[vuln.type] || 0) + 1;
            return acc;
        }, {});

        if (typeCount.hardcoded_password > 0) {
            recommendations.push({
                priority: 'high',
                action: 'Remove hardcoded passwords and use environment variables',
                description: 'Hardcoded passwords pose a significant security risk'
            });
        }

        if (typeCount.vulnerable_dependency > 0) {
            recommendations.push({
                priority: 'medium',
                action: 'Update vulnerable dependencies',
                description: 'Run npm update or yarn upgrade to fix known vulnerabilities'
            });
        }

        return recommendations;
    }

    /**
     * Generate HTML report
     */
    generateHTMLReport(report) {
        return `
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report - ${report.scanId}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .summary { display: flex; gap: 20px; margin: 20px 0; }
        .metric { background: #fff; border: 1px solid #ddd; padding: 15px; border-radius: 5px; flex: 1; }
        .critical { color: #d32f2f; }
        .high { color: #f57c00; }
        .medium { color: #fbc02d; }
        .low { color: #388e3c; }
        .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .recommendations { background: #e3f2fd; padding: 15px; border-radius: 5px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Vulnerability Scan Report</h1>
        <p><strong>Scan ID:</strong> ${report.scanId}</p>
        <p><strong>Generated:</strong> ${report.generatedAt}</p>
        <p><strong>Duration:</strong> ${report.duration}ms</p>
    </div>
    
    <div class="summary">
        <div class="metric">
            <h3>Total Vulnerabilities</h3>
            <div style="font-size: 2em; font-weight: bold;">${report.summary.total}</div>
        </div>
        <div class="metric">
            <h3>Risk Score</h3>
            <div style="font-size: 2em; font-weight: bold;">${report.summary.riskScore}</div>
        </div>
        <div class="metric">
            <h3>By Severity</h3>
            <div class="critical">Critical: ${report.summary.bySeverity.critical || 0}</div>
            <div class="high">High: ${report.summary.bySeverity.high || 0}</div>
            <div class="medium">Medium: ${report.summary.bySeverity.medium || 0}</div>
            <div class="low">Low: ${report.summary.bySeverity.low || 0}</div>
        </div>
    </div>

    <div class="recommendations">
        <h3>Recommendations</h3>
        ${report.recommendations.map(rec => `
            <div class="${rec.priority}">
                <strong>${rec.action}</strong><br>
                ${rec.description}
            </div>
        `).join('')}
    </div>

    <h3>Vulnerabilities</h3>
    ${report.vulnerabilities.map(vuln => `
        <div class="vulnerability ${vuln.severity}">
            <h4>${vuln.type} - ${vuln.severity.toUpperCase()}</h4>
            <p>${vuln.description}</p>
            ${vuln.package ? `<p><strong>Package:</strong> ${vuln.package}</p>` : ''}
            ${vuln.location ? `<p><strong>Location:</strong> ${vuln.location}</p>` : ''}
            ${vuln.recommendation ? `<p><strong>Fix:</strong> ${vuln.recommendation}</p>` : ''}
        </div>
    `).join('')}
</body>
</html>`;
    }

    /**
     * Handle critical vulnerabilities
     */
    async handleCriticalVulnerabilities(vulnerabilities) {
        const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
        
        if (criticalVulns.length > 0) {
            await this.auditLogger.logSecurityEvent('CRITICAL_VULNERABILITIES_FOUND', {
                count: criticalVulns.length,
                vulnerabilities: criticalVulns.map(v => ({
                    type: v.type,
                    description: v.description,
                    package: v.package,
                    location: v.location
                }))
            });

            this.emit('criticalVulnerabilitiesFound', criticalVulns);

            // Auto-fix if enabled
            if (this.config.autoFix) {
                await this.attemptAutoFix(criticalVulns);
            }
        }
    }

    /**
     * Attempt automatic fixes for vulnerabilities
     */
    async attemptAutoFix(vulnerabilities) {
        for (const vuln of vulnerabilities) {
            try {
                if (vuln.type === 'vulnerable_dependency' && vuln.recommendation.includes('Update')) {
                    await this.fixVulnerableDependency(vuln);
                }
            } catch (error) {
                await this.auditLogger.logSecurityEvent('AUTO_FIX_FAILED', {
                    vulnerability: vuln,
                    error: error.message
                });
            }
        }
    }

    /**
     * Fix vulnerable dependency
     */
    async fixVulnerableDependency(vulnerability) {
        // This would run npm update or similar commands
        console.log(`Would attempt to fix ${vulnerability.package}`);
    }

    /**
     * Start continuous scanning
     */
    startContinuousScanning() {
        this.scanTimer = setInterval(async () => {
            try {
                await this.runScan({ automated: true });
            } catch (error) {
                console.error('Automated scan failed:', error);
            }
        }, this.config.scanInterval);

        console.log(`Continuous scanning started with interval: ${this.config.scanInterval}ms`);
    }

    /**
     * Stop continuous scanning
     */
    stopContinuousScanning() {
        if (this.scanTimer) {
            clearInterval(this.scanTimer);
            this.scanTimer = null;
        }
    }

    /**
     * Generate scan ID
     */
    generateScanId() {
        return `scan_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    }

    /**
     * Get scan history
     */
    getScanHistory(limit = 10) {
        const scans = Array.from(this.scanHistory.values())
            .sort((a, b) => b.startTime - a.startTime)
            .slice(0, limit);
        
        return scans;
    }

    /**
     * Get vulnerability database
     */
    getVulnerabilities(filters = {}) {
        let vulns = Array.from(this.vulnerabilities.values());

        if (filters.severity) {
            vulns = vulns.filter(v => v.severity === filters.severity);
        }

        if (filters.type) {
            vulns = vulns.filter(v => v.type === filters.type);
        }

        if (filters.status) {
            vulns = vulns.filter(v => v.status === filters.status);
        }

        return vulns;
    }

    /**
     * Mark vulnerability as fixed
     */
    async markVulnerabilityFixed(vulnerabilityId, fixedBy) {
        const vuln = this.vulnerabilities.get(vulnerabilityId);
        if (vuln) {
            vuln.status = 'fixed';
            vuln.fixedAt = new Date();
            vuln.fixedBy = fixedBy;

            await this.auditLogger.logSecurityEvent('VULNERABILITY_FIXED', {
                vulnerabilityId,
                type: vuln.type,
                severity: vuln.severity,
                fixedBy
            });

            this.emit('vulnerabilityFixed', vuln);
        }
    }

    /**
     * Get scanner statistics
     */
    getScannerStats() {
        return {
            totalScans: this.scanHistory.size,
            totalVulnerabilities: this.vulnerabilities.size,
            enabledScanners: Array.from(this.scanners.entries())
                .filter(([, scanner]) => scanner.enabled)
                .map(([id, scanner]) => ({ id, name: scanner.name })),
            continuousScanning: !!this.scanTimer,
            config: this.config
        };
    }

    /**
     * Destroy vulnerability scanner
     */
    async destroy() {
        this.stopContinuousScanning();
        
        await this.auditLogger.logSecurityEvent('VULNERABILITY_SCANNER_DESTROYED', {
            timestamp: new Date()
        });
    }
}

export default VulnerabilityScanner;

